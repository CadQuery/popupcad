# -*- coding: utf-8 -*-
"""
Created on Thu Jul  2 12:52:50 2015

@author: skylion
"""

import trollius #NOTE: Trollius requires protobuffer from Google
from trollius import From

import pygazebo
import pygazebo.msg.joint_cmd_pb2
import time 

try:
    import itertools.izip as zip
except ImportError:
    pass

def apply_joint_forces(world_name, robot_name, joint_names, forces, duration=-1):
    wait_net_service('localhost',11345)

    @trollius.coroutine 
    def joint_force_loop(world_name, robot_name, joint_name, force, duration=-1):
        manager = yield From(pygazebo.connect())
        print("connected")
        
        
        publisher = yield From(
            manager.advertise('/gazebo/' + world_name + '/' + robot_name + '/joint_cmd',
                              'gazebo.msgs.JointCmd'))
    
        message = pygazebo.msg.joint_cmd_pb2.JointCmd()
        message.name = robot_name + '::' + joint_name #format should be: name_of_robot + '::name_of_joint'
        message.force = force
        
        t_end = time.time() + duration # The time that you want the controller to stop
        while time.time() < t_end or duration == -1:
            print(message)            
            try:
                yield From(publisher.publish(message))
                yield From(trollius.sleep(1.0))
            except:
                pass
                break
        print("Connection closed")
        
    def loop_in_thread(loop, tasks):
        trollius.set_event_loop(loop)
        loop.run_until_complete(trollius.wait(tasks))
        
    tasks = []
    for joint_name, force in zip(joint_names, forces):
        tasks.append(trollius.Task(joint_force_loop(world_name, robot_name, joint_name, force, duration)))
    
    #Experimental code to make this loop non-blocking
    #loop = trollius.get_event_loop()
    #loop_thread_tasks = lambda t_loop: loop_in_thread(t_loop, tasks)
    #import threading
    #t = threading.Thread(target=loop_thread_tasks, args=(loop,))
    #t.start()
    #return t
    loop = trollius.get_event_loop()
    loop.run_until_complete(trollius.wait(tasks))
    
    
    
def wait_net_service(server, port, timeout=None):
    """ Wait for network service to appear 
        @param timeout: in seconds, if None or 0 wait forever
        @return: True of False, if timeout is None may return only True or
                 throw unhandled network exception
    """
    import socket
    import errno

    s = socket.socket()
    if timeout:
        from time import time as now
        # time module is needed to calc timeout shared between two exceptions
        end = now() + timeout

    while True:   
        try:
            if timeout:
                next_timeout = end - now()
                if next_timeout < 0:
                    return False
                else:
            	    s.settimeout(next_timeout)
            s.connect((server, port))
        except socket.timeout, err:
            # this exception occurs only if timeout is set
            if timeout:
                return False
      
        except socket.error, err:
            # catch timeout exception from underlying network library
            # this one is different from socket.timeout
            if type(err.args) != tuple or (err[0] != errno.ETIMEDOUT and err[0] != errno.ECONNREFUSED):
                raise err
        else:
            s.close()
            return True

#Export to Gazebo
def export(self):
	joint_laminates = self.bodies_generic
	for laminate in joint_laminates:
	    laminate.toDAE()


	project_name = "exported" #We can figure out a better way later.
	world_name = 'world'
	robot_name = 'default_body'        

	global_root = etree.Element("sdf", version="1.5")

	world_object = etree.Element("world", name=world_name)
	global_root.append(world_object);

	model_object = etree.Element("model", name=robot_name)
	world_object.append(model_object)

	etree.SubElement(model_object, "static").text = "false"
	etree.SubElement(model_object, "pose").text = "0 0 0 0 0 0"

	world_object.append(createFloor())

	counter = 0
	for joint_laminate in joint_laminates:
	    model_object.append(createRobotPart(joint_laminate, counter))
	    counter+=1

	counter = 0
	for joint_connection in self.connections:
	    model_object.append(self.craftJoint(joint_connection, counter))
	    counter+=1

	#Fixed joint method
	#joint_root = etree.SubElement(model_object, "joint", {'name':'atlas', 'type':'revolute'})
	#etree.SubElement(joint_root, 'parent').text = 'world'
	#etree.SubElement(joint_root, 'child').text = str(self.connections[0][1][0].id)
		#axis = etree.SubElement(joint_root, "axis")
		#etree.SubElement(axis, "xyz").text = "0 1 0"
		#limit = etree.SubElement(axis, "limit")
		#etree.SubElement(limit, "upper").text = '0'
		#etree.SubElement(limit, "lower").text = '0'
		
		#Manually specify the physics engine
		#physics = etree.SubElement(world_object, 'physics', {'name':'default', 'default':'true', 'type':'dart'})
		#etree.SubElement(physics, 'max_step_size').text = str(0.0001)
		#etree.SubElement(physics, "real_time_factor").text = "0.1"
		
		#Saves the object
		file_output = popupcad.exportdir + os.path.sep + project_name + ".world"
		f = open(file_output,"w")
		f.write(etree.tostring(global_root, pretty_print=True))
		f.close()
		
		#TODO replace with Subprocess to prevent pollution of STDOUT
		os.system("gazebo -e dart " + file_output + " &")
		
		
		from gazebo_controller import apply_joint_forces

		joint_names = []        
		for num in range(0, len(self.all_joint_props)):
		    joint_names.append("hingejoint" + str(num))
		
		joint_forces = [joint_def[2] for joint_def in self.all_joint_props]
		apply_joint_forces(world_name, robot_name, joint_names, joint_forces)
